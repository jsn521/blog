/*  Basic DOM handler */

// Node: Element or Text
var Node = new Function();

Node.prototype.__defineGetter__('textContent', function() {
    if (this.isTextNode()) {
        return this.text;
    }
    else {
        var text = '', i = 0;
        while (i < this.children.length) {
            text += this.children[i++].textContent;
        }
        return text;
    }
});

Node.prototype.isTextNode = function() {
    return this.constructor == Text;
};

var Text = function(text) {
    this.text = text;
};

Text.prototype = new Node();
Text.prototype.constructor = Text;

var Element = function(tag) {
    this.name = tag ? tag.name : '';
    this.attributes = tag ? tag.attributes : {};
    this.children = [];
};

Element.prototype = new Node();
Element.prototype.constructor = Element;

Element.prototype.filterElements = function(test) {
    var elems = [];
    if (test(this)) {
        elems.push(this);
    }
    for (var i = 0; i < this.children.length; i++) {
        elems.push.apply(elems, this.children[i].filterElements(test));
    }
    return elems;
};

Element.prototype.findElement = function(test) {
    if (test(this)) {
        return this;
    }
    else {
        for (var i = 0; i < this.children.length; i++) {
            var el = children[i].findElement(test);
            if (el) {
                return el;
            }
        }
    }
    return false;
};

var self_closing = ['area','base','br','col','command','embed','hr','img',
    'input','keygen','link','meta','param','source','track','wbr'];

exports.Tree = Tree = function() {
    this.document = new Element();      // root element
    this.currentNode = this.document;   // top of stack of open elements
    this.currentText = '';              // text buffer
};

Tree.prototype.emitText = function(text) {
    this.currentText += text;
};

Tree.prototype.writeTextNode = function() {
    // write text buffer to child node of current node
    if (this.currentText !== '') {
        var node = new Text(this.currentText);
        this.currentNode.children.push(node);
        this.currentText = '';
    }
};

Tree.prototype.emitTag = function(tag) {
    var node = new Element(tag);

    this.writeTextNode();

    if (this.currentNode.name == 'p' && node.name == 'p') {
        // don't nest paragraphs
        this.currentNode = this.currentNode.parent;
    }

    node.parent = this.currentNode;
    this.currentNode.children.push(node);

    // don't open self-closing tags
    for (var i = 0; len = self_closing.length; i < len; i++) {
        if (self_closing[i] == node.name) {
            this.currentNode = node;
            break;
        }
    }
};

Tree.prototype.emitEndTag = function(name) {
    var node = this.currentNode;

    // traverse stack of open elements to find match
    while (node.parent && node.name != name) {
        node = node.parent;
    }

    if (node.name == name) {
        this.writeTextNode();
        this.currentNode = node.parent;
    }
    else if (name == 'br') {
        // convert stray </br> to <br>
        this.emitTag({
            name: 'br',
            attributes: {}
        });
    }

    // discard if no match
};
